\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{color}
\definecolor{blue1}{RGB}{0,102,204}
%% \usepackage[colorlinks=true,linkcolor=blue1,citecolor=blue1,urlcolor=blue1]{hyperref}
\usepackage[colorlinks=true,linkcolor=blue,citecolor=blue,urlcolor=blue]{hyperref}
\usepackage{array}
\usepackage[english]{babel}
\usepackage{amsfonts}
\usepackage{url}
\usepackage{bm}
\usepackage[margin=2.5cm]{geometry}
\usepackage[affil-it]{authblk}

\newcommand{\R}{\mathbb{R}}
\newcommand{\beq}{\begin{equation}}
\newcommand{\eeq}{\end{equation}}
\newcommand{\m}[1]{\mathbf{#1}}
\newcommand{\rcmd}[1]{\textcolor{red}{\texttt{#1}}}
\newcommand{\code}[1]{{{\tt #1}}}
\newcommand{\Rlogo}{\includegraphics[width=0.05\textwidth]{figs/Rlogo.pdf}}

\title{An introduction to \textit{adegenet} \Sexpr{packageDescription("adegenet", fields = "Version")}}

\author{Thibaut Jombart
  \thanks{\texttt{tjombart@imperial.ac.uk}}
}
\affil{{\footnotesize Imperial College London \\MRC Centre for Outbreak Analysis and Modelling}}

%% \date{\today}
\date{\today}

\sloppy
\hyphenpenalty 10000

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}
\selectlanguage{english}

<<include=FALSE>>=
knitr::opts_chunk$set(fig.path='figs/base-', fig.keep='high', dev='pdf',
  fig.width=7, fig.height=7, tidy=FALSE, warning=FALSE, fig.show="asis",
  fig.align='center', out.width=".8\\textwidth")
@


\color{black}

\maketitle

\begin{abstract}
  This vignette provides an introductory tutorial to the \textit{adegenet} package \cite{tjart05}
  for the R software \cite{np145}. This package implements tools to handle, analyse and simulate
  genetic data. Originally developped for multiallelic, codominant markers such as microsatellites,
  \textit{adegenet} now also handles dominant markers, allows for any ploidy in the data, handles
  SNPs and sequence data, and implements a memory-efficient storage for genome-wide SNP data.
  This tutorial provides an overview of \textit{adegenet}'s basic functionalities. Since
  \textit{adegenet} 1.4-0, this tutorial is no longer distributed as a package vignette. Also note
  that \textit{adegenet} has undergone substantial changes with version 2.0.0, including a reform of
  the data structure and new accessors, all documented in this tutorial.
\end{abstract}


\newpage
\tableofcontents




\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
This tutorial introduces some basic functionalities of the \textit{adegenet} package for R \cite{np145}.
The purpose of this package is to provide tools for handling, analysing and simulating genetic
data, with an emphasis on multivariate approaches and exploratory methods.
Standard multivariate analyses are implemented in the \textit{ade4} package \cite{tj548}, of which
\textit{adegenet} was originally an extension.
However, the package has since grown methods of its own such as the Discriminant Analysis of
Principal Components (DAPC, \cite{tjart19}), the spatial Principal Components Analysis (sPCA,
\cite{tjart04}), or the \textit{SeqTrack} algorithm \cite{tjart20}.
In this tutorial, we introduce the main data structures, show how to import data into
\textit{adegenet}, and cover some basic population genetics and multivariate analysis.
\\

Other tutorials are available via the command \texttt{adegenetTutorial}:
\begin{itemize}
 \item \texttt{adegenetTutorial("spca")}: tutorial on the sPCA
 \item \texttt{adegenetTutorial("dapc")}: tutorial on the DAPC
 \item \texttt{adegenetTutorial("genomics")}: tutorial on handling large SNP datasets using
   \texttt{genlight} objects
 \item \texttt{adegenetTutorial("strata")}: tutorial on handling stratified population data
\end{itemize}
%% Data can be imported from a wide range of formats, including those of
%% popular population genetics software (GENETIX, STRUCTURE, Fstat, Genepop), or from simple dataframes of genotypes.
%% Polymorphic sites can be extracted from both nucleotide and amino-acid sequences, with special
%% methods for handling genome-wide SNPs data with miminum RAM requirements.
%% \\

%% In this tutorial, we first introduce the \texttt{genind} and \texttt{genpop} classes used to store
%% multiallelic markers (respectively for individuals and populations), and then show how to extract
%% information from these objects using a variety of tools. Other tutorials are dedicated to some
%% specific topics:
%% \begin{itemize}
%% \item sPCA: dedicated to the spatial Principal Components Analysis.
%% \item DAPC: dedicated to the Discriminant Analysis of Principal Components.
%% \item genomics: dedicated to memory-efficient genome-wide SNP data handling and analysis using the \texttt{genlight} class.
%% \end{itemize}




\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Getting started}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Installing the package - stable version}
%%%%%%%%%%%%%%%%%%%%%%%%%%
Before going further, we shall make sure that \textit{adegenet} is well installed
on the computer.
The current version of the package is \Sexpr{packageDescription("adegenet", fields = "Version")}.
Make sure you have a recent version of R ($\geq 3.2.1$) by typing:
<<>>=
R.version.string
@

Then, install \textit{adegenet} with dependencies using:
<<eval=FALSE>>=
install.packages("adegenet", dep=TRUE)
@

We can now load the package alongside other useful packages:
<<results="hide", message=FALSE>>=
library("ape")
library("pegas")
library("seqinr")
library("ggplot2")
@
<<>>=
library("adegenet")
@

If at some point you are unsure about the version of the package, you can check it using:
<<>>=
packageDescription("adegenet", fields = "Version")
@
\textit{adegenet} version should read \Sexpr{packageDescription("adegenet", fields = "Version")}.


%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Installing the package - devel version}
%%%%%%%%%%%%%%%%%%%%%%%%%%
The development of \textit{adegenet} is hosted on github:\\
\url{https://github.com/thibautjombart/adegenet}.

You can install this version using the package \textit{devtools} and the following commands:
<<eval=FALSE>>=
library("devtools")
install_github("thibautjombart/adegenet")
library("adegenet")
@

The development version may implement new features and fix known issues. However, it may also
occasionally be broken, as this is our working copy of the project.
Usual disclaimers apply here: this package is provided with no warranty, etc.
If unsure, use the stable version.


%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Getting help in R}
%%%%%%%%%%%%%%%%%%%%%%%%%%
There are several ways of getting information about R in general, and about
\textit{adegenet} in particular.
The function \texttt{help.search} is used to look for help on a given topic.
For instance:
<<eval=FALSE>>=
help.search("Hardy-Weinberg")
@
replies that there is a function \texttt{HWE.test.genind} in the
\textit{adegenet} package, and other similar functions in \textit{genetics} and \textit{pegas}.
To get help for a given function, use \texttt{?foo} where \texttt{foo} is the
function of interest.
For instance (quotes and parentheses can be removed):
<<eval=FALSE>>=
?spca
@
will open up the manpage of the spatial principal component analysis \cite{tjart04}.
At the end of a manpage, an `example' section often shows how to use a function.
This can be copied and pasted to the console, or directly executed
from the console using \texttt{example}.
For further questions concerning R, the function \texttt{RSiteSearch}
is a powerful tool for making online researches using keywords in R's archives (mailing
lists and manpages).
\\


\textit{adegenet} has a few extra documentation sources.
Information can be found from the website
(\url{http://adegenet.r-forge.r-project.org/}), in the `documents'
section, including several tutorials and a manual which compiles all
manpages of the package, and a dedicated mailing list with searchable archives.
To open the website from R, use:
<<eval=FALSE>>=
adegenetWeb()
@
The same can be done for tutorials, using \texttt{adegenetTutorial} (see
manpage to choose the tutorial to open).
You will also find an overview of the main functionalities of the package typing:
<<eval=FALSE>>=
?adegenet
@

Note that you can also browse help pages as html pages, using:
<<eval=FALSE>>=
help.start()
@
To go to the \textit{adegenet} page, click `packages', `adegenet', and
`adegenet-package'.
\\



%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Asking help on a forum}
%%%%%%%%%%%%%%%%%%%%%%%%%%
Several mailing lists are available to find different kinds of
information on R.
\textit{adegenet} has its own dedicated forum/mailing list:
\url{adegenet-forum@lists.r-forge.r-project.org}
To avoid spam, this list is filtered; subscription is recommended, and can be done at:
\url{https://lists.r-forge.r-project.org/cgi-bin/mailman/listinfo/adegenet-forum}
\\

Posting questions on R forums can sometimes be a traumatic experience, and we are trying to avoid
this as much as possible on the adegenet forum.
To this end, the following points are worth keeping in mind:
\begin{itemize}
\item \textbf{read the doc first:} manpages and tutorials take an awful long time to write and
  maintain; make sure your answer is not in an obvious place before asking a question; pretending to
  have read all the available doc while you have not even looked at the basics tutorial is a clever,
  yet often unsuccessful strategy.
\item \textbf{search the archives:} adegenet forum has searchable archives (see the adegenet
  website); your answer may be there already, so it is worth checking.
\item \textbf{give us info:} you tried something, it is not working.. give us some information: what
  version of adegenet are you using, what commands did you enter and what was the output, etc.
\item \textbf{avoid personal messages:} the adegenet forum has plenty of advantages: several people
  are likely to reply and participate in the conversation, answers are generally faster, and all of
  this is archived and searchable. Please do not email the developers directly, unless you need to
  discuss confidential matters.
\item \textbf{short answers are okay:} some answers will be short. Do not take them as rude, or
  think people are upset: answering questions on a forum is a time-consuming activity and the reward
  for it is low. Sometimes the best answer will be pointing to relevant documentation,
  e.g. ``Please check ?xvalDapc''. If you get this, we (most likely) still like you.
\end{itemize}


The adegenet forum is not the only forum that might be relevant.
Others include:
\begin{itemize}
\item \textit{R-sig-genetics}: genetics in R.\\
  \url{https://stat.ethz.ch/mailman/listinfo/r-sig-genetics}
\item \textit{R-sig-phylo}: phylogenetics in R.\\
  \url{https://stat.ethz.ch/mailman/listinfo/r-sig-phylo}
\item \textit{R-help}: general questions about R.\\
  \url{https://stat.ethz.ch/mailman/listinfo/r-help}
\item \textit{stackoverflow.com}: general questions about R.\\
  \url{http://stackoverflow.com/questions/tagged/r}
\end{itemize}

Please avoid double-posting (it is often considered to be rude).



%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Bug report, feature requests, contributions: we are all one!}
%%%%%%%%%%%%%%%%%%%%%%%%%%
Free software evolves through interactions between communities of developers and users.
This is especially true in R, where these two communities are very much intermingled.
In short: \textbf{we are all contributors!}
These contributions include:
\begin{itemize}
  \item \textbf{asking a question:} see section above
  \item \textbf{asking for a new feature:} something useful is missing, and you think it will be
    useful to others? Say it! Post a feature request using github's \emph{issues}:\\
    \url{https://github.com/thibautjombart/adegenet/issues}
  \item \textbf{reporting a possible bug:} bugs are rare, but if you think you found one, post it as
    an issue on github: \\
    \url{https://github.com/thibautjombart/adegenet/issues}
  \item \textbf{contributions:} github makes contributions very easy; fork the project, make the
    changes you want, and when you are happy and the package passes the checks, send a pull request;
    for more on this go to the github page:\\
    \url{https://github.com/thibautjombart/adegenet}
    And please, remember to add yourself as a contributor in the DESCRIPTION and relevant manpages!
\end{itemize}




\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Object classes}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Two main classes of objects are used for storing
genetic marker data, depending on the level at which the genetic information is considered:
\texttt{genind} is used for individual genotypes, whereas \texttt{genpop} is used for alleles
numbers counted by populations.  Note that the term 'population', here and later, is employed in a
broad sense: it simply refers to any grouping of individuals.  The specific class \texttt{genlight}
is used for storing large genome-wide SNPs data.  See the \textit{genomics} tutorial for more
information on this topic.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{genind objects}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
These objects store \textbf{gen}etic data at an \textbf{ind}ividual level, plus various meta-data
(e.g. group membership).
\texttt{genind} objects can be obtained by reading data files from other software,
from a \texttt{data.frame} of genotypes, by conversion from a table of
allele counts, or even from aligned DNA or proteic sequences (see 'importing data').
Here, we introduce this class using the dataset \texttt{nancycats}, which is already stored as a
\texttt{genind} object:
<<genind>>=
data(nancycats)
is.genind(nancycats)
nancycats
@
A \texttt{genind} object is formal S4 object with several slots,
accessed using the '\texttt{@}' operator (see \texttt{class?genind}).
Note that the '\texttt{\$}' is also implemented for adegenet objects,
so that slots can be accessed as if they were components of a list.
\\

\texttt{genind} objects possess the following slots:
\begin{itemize}
  \item \texttt{tab}: a matrix of alleles counts (individuals in rows, alleles in columns).
  \item \texttt{loc.n.all}: the number of alleles in each marker.
  \item \texttt{loc.fac}: a factor indicating which columns in \texttt{@tab} correspond to which marker.
  \item \texttt{all.names}: a list of allele names for each locus.
  \item \texttt{ploidy}: a vector of integer indicating the ploidy of each individual; constant
    ploidy is assumed across different loci of a single individual, but different individuals can
    have different ploidy.
  \item \texttt{type}: a character string indicating whether the marker is codominant
    (\texttt{codom}) or presence/absence (\texttt{PA}).
  \item \texttt{call}: the matched call, i.e. command used to create the object.
  \item \texttt{pop}: (optional) a factor storing group membership of the individuals; when present,
    method needing a population information will automatically use this if nothing else is provided.
  \item \texttt{strata}: (optional) a data.frame storing hierarchical structure of individuals (see
    dedicated tutorial).
  \item \texttt{hierarchy}: (optional) a formula defining the hierarchical structure of individuals (see
    dedicated tutorial).
  \item \texttt{other}: (optional) a list storing optional information.
\end{itemize}
Slots can be accessed using '\texttt{@}' or '\texttt{\$}', although \textbf{it is recommended to use
accessors to retrieve and change slot values (see section 'Using accessors')}.
\\

The main slot of a \texttt{genind} is the table of allelic counts \texttt{@tab}, with individuals in rows and
alleles in columns.
For instance:
<<>>=
nancycats[10:18, loc="fca8"]@tab
@
Individual 'N224' is an homozygote for the allele 135 at the locus 'fca8', while N141'' is an heterozygote with alleles 129/133.
Note that as of \textit{adegenet} 2.0.0, this table is no storing data as relative frequencies. These can
still be obtained using the accessor '\texttt{tab}'.
The particular case of presence/absence data is described in a
dedicated section (see 'Handling presence/absence data').
As of version 2.0.0 of adegenet, the slots \texttt{@strata} and \texttt{@hierarchy} implement
hierarchical population structures. See dedicated tutorial for more on this topic.
\\


Note that objects can be regenerated using the matched call stored in \textit{genind} objects, \textit{i.e.} the instruction that created it.
For instance:
<<>>=
obj <- read.genetix(system.file("files/nancycats.gtx",package="adegenet"))
obj$call
toto <- eval(obj$call)
identical(obj,toto)
@


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{genpop objects}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
These objects store \textbf{gen}etic data at a \textbf{pop}ulation level, plus various meta-data.
Their struture is nearly identical to \texttt{genind} objects, only simpler as they no longer store
group membership for individuals.
\texttt{genpop} objects are created from \texttt{genind} objects using \texttt{genind2genpop}:
<<>>=
data(nancycats)
catpop <- genind2genpop(nancycats)
catpop
@

As in \texttt{genind} objects, data are stored as numbers of alleles, but this time for populations
(here, cat colonies):
<<>>=
tab(catpop)[1:5, 1:10] # using the accessor for the allele table
@



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Using accessors}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
One advantage of formal (S4) classes is that they allow for interacting simply with possibly complex objects.
This is made possible by using accessors, i.e. functions that extract information from an object,
rather than accessing the slots directly.
Another advantage of this approach is that as long as accessors remain identical on the user's
side, the internal structure of an object may change from one release to another without generating
errors in old scripts.
Although \texttt{genind} and \texttt{genpop} objects are fairly simple, we recommend using accessors whenever possible
to access or modify their content.
\\

Available accessors are:
\begin{itemize}
  \item \texttt{nInd}: returns the number of individuals in the object; only for \texttt{genind}.
  \item \texttt{nLoc}: returns the number of loci.
  \item \texttt{nAll}: returns the number of alleles for each locus.
  \item \texttt{nPop}: returns the number of populations.
  \item \texttt{tab}: returns a table of allele numbers, or frequencies (if requested), with
    optional replacement of missing values; replaces the former accessor '\texttt{truenames}'.
  \item \texttt{indNames}$^{\dagger}$: returns/sets labels for individuals; only for \texttt{genind}.
  \item \texttt{locNames}$^{\dagger}$: returns/sets labels for loci.
  \item \texttt{alleles}$^{\dagger}$: returns/sets alleles.
  \item \texttt{ploidy}$^{\dagger}$: returns/sets ploidy of the individuals; when setting values, a
    single value can be provided, in which case constant ploidy is assumed.
  \item \texttt{pop}$^{\dagger}$: returns/sets a factor grouping individuals; only for \texttt{genind}.
  \item \texttt{strata}$^{\dagger}$: returns/sets data defining strata of individuals; only for \texttt{genind}.
  \item \texttt{hier}$^{\dagger}$: returns/sets hierarchical groups of individuals; only for \texttt{genind}.
  \item \texttt{other}$^{\dagger}$: returns/sets misc information stored as a list.
\end{itemize}
where $^{\dagger}$ indicates that a replacement method is available using \texttt{<-}; for instance:
<<>>=
head(indNames(nancycats),10)
indNames(nancycats) <- paste("cat", 1:nInd(nancycats),sep=".")
head(indNames(nancycats),10)
@

\noindent Some accessors such as \texttt{locNames} may have specific options; for instance:
<<>>=
locNames(nancycats)
@
returns the names of the loci, while:
<<>>=
temp <- locNames(nancycats, withAlleles=TRUE)
head(temp, 10)
@
returns the names of the alleles in the form 'loci.allele'.
\\

\noindent The slot 'pop' can be retrieved and set using \texttt{pop}:
<<>>=
obj <- nancycats[sample(1:50,10)]
pop(obj)
pop(obj) <- rep("newPop",10)
pop(obj)
@
Accessors make things easier. For instance, when setting new names for loci, the columns of
\texttt{@tab} are renamed automatically:
<<>>=
head(colnames(tab(obj)),20)
locNames(obj)
locNames(obj)[1] <- "newLocusName"
locNames(obj)
head(colnames(tab(obj)),20)
@

An additional advantage of using accessors is they are most of the time safer to use. For instance,
\texttt{pop<-} will check the length of the new group membership vector against the data, and
complain if there is a mismatch. It also converts the provided replacement to a factor, while the command:
<<eval=TRUE>>=
obj@pop <- rep("newPop",10)
@
generates an error (since replacement is not a factor).







\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Importing/exporting data}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Importing data from GENETIX, STRUCTURE, FSTAT, Genepop}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Data can be read from the software GENETIX (extension .gtx), STRUCTURE (.str or
.stru), FSTAT (.dat) and Genepop (.gen) files, using the corresponding
\texttt{read} function: \texttt{read.genetix},  \texttt{read.structure},
\texttt{read.fstat}, and  \texttt{read.genepop}.
These functions take as main argument the path (as a string of characters) to an input file, and produce a \texttt{genind} object.
Alternatively, one can use the function \texttt{import2genind} which detects a file format from its extension and uses the appropriate routine.
For instance:
<<import>>=
obj1 <- read.genetix(system.file("files/nancycats.gtx",package="adegenet"))
obj2 <- import2genind(system.file("files/nancycats.gtx", package="adegenet"))
all.equal(obj1,obj2)

@

\noindent The only difference between \texttt{obj1} and \texttt{obj2} is
their call (which is normal as they were obtained from different
command lines).




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Importing data from other software}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Raw genetic markers data are often stored as tables with individuals in row and markers
in column, where each entry is a character string coding the alleles possessed at one locus.
Such data are easily imported into R as a \texttt{data.frame}, using for instance \texttt{read.table}
for text files or \texttt{read.csv} for comma-separated text files.
Then, the obtained \texttt{data.frame} can be converted into a \texttt{genind} object using \texttt{df2genind}.
\\

There are only a few pre-requisite the data should meet for this conversion to be possible. The
easiest and clearest way of coding data is using a separator between alleles. For instance,
"80/78'', "80|78", or "80,78'' are different ways of coding a genotype at a microsatellite locus
with alleles '80' and 78".
Note that for haploid data, no separator shall be used.
The only contraint when using a separator is that the same separator is used in all the
dataset. There are no contraints as to i) the type of separator used or ii) the ploidy of the data.
These parameters can be set in \texttt{df2genind} through arguments \texttt{sep} and \texttt{ploidy}, respectively.
\\

Alternatively, no separator may be used provided a fixed number of characters is used to code each allele.
For instance, in a diploid organism, "0101" is an homozygote 1/1 while "1209" is a heterozygote
12/09 in a two-character per allele coding scheme.
In a tetraploid system with one character per allele, "1209" will be understood as 1/2/0/9.

Here, we provide an example using randomly generated tetraploid data and no separator.
<<>>=
temp <- lapply(1:30, function(i) sample(1:9, 4, replace=TRUE))
temp <- sapply(temp, paste, collapse="")
temp <- matrix(temp, nrow=10, dimnames=list(paste("ind",1:10), paste("loc",1:3)))
temp
obj <- df2genind(temp, ploidy=4, sep="")
obj
@

\noindent \texttt{obj} is a \texttt{genind} containing the same information, but recoded as a matrix of allele
numbers (\texttt{\$tab} slot).
We can check that the conversion was exact by converting back the object into a table of character
strings (function \texttt{genind2df}):
<<>>=
genind2df(obj, sep="|")
@





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Handling presence/absence data}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\textit{adegenet} was primarly designed to handle codominant, multiallelic markers like microsatellites.
However, dominant markers like AFLP can be used as well.
In such a case, only presence/absence of alleles can be deduced accurately from
the genotypes.
This has several consequences, like the unability to compute allele frequencies.
Hence, some functionalities in \textit{adegenet} won't be available for
dominant markers.

From version 1.2-3 of \textit{adegenet}, the distinction between both types of markers is made by the slot
\texttt{@type} of genind or genpop objects, which equals \texttt{codom} for
codominant markers, and \texttt{PA} for presence/absence data.
In the latter case, the 'tab' slot of a genind object no longer contains allele
frequencies, but only presence/absence of alleles in a genotype.
Similarly, the \texttt{tab} slot of a genpop object not longer contains
counts of alleles in the populations; instead, it contains the number
of genotypes in each population possessing at least one copy of the concerned alleles.
Moreover, in the case of presence/absence, the slots 'loc.n.all', 'loc.fac', and 'all.names'
become useless, and are thus all set to NULL.
\\


Objects of type 'PA' are otherwise handled like usual (type 'codom')
objects.
Operations that are not available for PA type will issue an appropriate error message.

Here is an example using a toy dataset 'AFLP.txt' that can be downloaded
from the adegenet website, section 'Documentation':
<<aflpread>>=
dat <- read.table(system.file("files/AFLP.txt",package="adegenet"), header=TRUE)
dat
@
\noindent The function \texttt{df2genind} is used to obtain a genind object:
<<>>=
obj <- df2genind(dat, ploidy=1, type="PA")
obj
tab(obj)
@

One can see that for instance, the summary of this object is more simple (no numbers of alleles per locus, no heterozygosity):
<<>>=
pop(obj) <- rep(c('a','b'),4:3)
print(summary(obj))
@

\noindent But we can still perform basic manipulation, like converting
our object into a genpop:
<<>>=
obj2 <- genind2genpop(obj)
obj2
tab(obj2)
@

\noindent To continue with the toy example, we can perform a simple PCA.
Allele presence absence data are extracted and NAs replaced using \texttt{tab}:
<<>>=
X <- tab(obj, NA.method="mean")
@

\noindent Now the PCA is performed and plotted:
<<pcaaflp>>=
## make PCA
pca1 <- dudi.pca(X,scannf=FALSE,scale=FALSE)
temp <- as.integer(pop(obj))
myCol <- transp(c("blue","red"),.7)[temp]
myPch <- c(15,17)[temp]

## basic plot
plot(pca1$li, col=myCol, cex=3, pch=myPch)

## use wordcloud for non-overlapping labels
library(wordcloud)
textplot(pca1$li[,1], pca1$li[,2], words=rownames(X), cex=1.4, new=FALSE)

## legend the axes by adding loadings
abline(h=0,v=0,col="grey",lty=2)
s.arrow(pca1$c1*.5, add.plot=TRUE)
legend("topright", pch=c(15,17), col=transp(c("blue","red"),.7),
       leg=c("Group A","Group B"), pt.cex=2)
@

\noindent More generally, multivariate analyses from ade4, sPCA (\texttt{spca}), DAPC
(\texttt{dapc}), the global and local tests (\texttt{global.rtest}, \texttt{local.rtest}), or
the Monmonier's algorithm (\texttt{monmonier}) will work just fine
with presence/absence data.
However, it is clear that the usual Euclidean distance (used in PCA
and sPCA), as well as many other distances, is not as accurate to measure genetic dissimilarity using
presence/absence data as it is when using allele frequencies.
The reason for this is that in presence/absence data, a part of the
information is simply hidden.
For instance, two individuals possessing the same allele will be
considered at the same distance, whether they possess one or more
copies of the allele.
This might be especially problematic in organisms having a high degree
of ploidy.





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{SNPs data}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
In \textit{adegenet}, SNP data can be handled in two different ways.
For relatively small datasets (up to a few thousand SNPs) SNPs can
be handled as usual codominant markers such as microsatellites using \texttt{genind} objects.
In the case of genome-wide SNP data (from hundreds of thousands to millions of SNPs),
\texttt{genind} objects are no longer efficient representation of the data.
In this case, we use \texttt{genlight} objects to store and handle information with maximum
efficiency and minimum memory requirements. See the tutorial \textit{genomics} for more information.
Below, we introduce only the case of SNPs handled using \texttt{genind} objects.
\\

The most convenient way to convert SNPs into a \texttt{genind} is using \texttt{df2genind}, which is
described in the previous section.
Let \texttt{dat} be an input matrix, as can be read into R using \texttt{read.table} or \texttt{read.csv},
with genotypes in row and SNP loci in columns.
<<>>=
dat <- matrix(sample(c("a","t","g","c"), 15, replace=TRUE),nrow=3)
rownames(dat) <- paste("genot.", 1:3)
colnames(dat) <- 1:5
dat
obj <- df2genind(dat, ploidy=1)
tab(obj)
@

\texttt{obj} is a \texttt{genind} containing the SNPs information, which can be used for further
analysis in adegenet.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Extracting polymorphism from DNA sequences}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
This section only covers the cases of relatively small datasets which can be handled efficiently
using \texttt{genind} objects. For bigger (near full-genomes) datasets, SNPs can be extracted from
\textit{fasta} files into a \texttt{genlight} object using \texttt{fasta2genlight}.
See the tutorial on \textit{genomics} for more information.
\\


DNA sequences can be read into R using \textit{ape}'s \texttt{read.dna} (fasta and clustal formats), or \textit{adegenet}'s
\texttt{fasta2DNAbin} for a RAM-greedy implementation (fasta alignments only).
Other options include reading data directly from GenBank using \texttt{read.GenBank}, or from other
public databases using the \textit{seqinr} package and transforming the \texttt{alignment} object into a
\texttt{DNAbin} using \texttt{as.DNAbin}.
Here, we illustrate this approach by re-using the example of \texttt{read.GenBank}. A connection to
the internet is required, as sequences are read directly from a distant database.
<<>>=
library(ape)
ref <- c("U15717", "U15718", "U15719", "U15720",
         "U15721", "U15722", "U15723", "U15724")
myDNA <- read.GenBank(ref)
myDNA
class(myDNA)
myDNA <- as.matrix(myDNA)
@

Polymorphism can be characterized using \texttt{snpposi.plot} and \texttt{snpposi.test}: the first
plots SNP density along the alignment, the second tests whether these SNPs are randomly distributed.
For instance:
<<>>=
snpposi.plot(myDNA,codon=FALSE)
@
By default, the function differentiates nucleotide positions:
<<>>=
snpposi.plot(myDNA)
@

In \textit{adegenet}, only polymorphic loci are conserved to form a \textit{genind} object.
This conversion is achieved by \texttt{DNAbin2genind}.
This function allows one to specify a threshold for polymorphism; for instance, one could retain
only SNPs for which the second largest allele frequency is greater than 1\% (using the \texttt{polyThres} argument).
This is achieved using:
<<>>=
obj <- DNAbin2genind(myDNA, polyThres=0.01)
obj
@
Here, out of the 1,045 nucleotides of the sequences, 318 SNPs where extracted and stored as a
\texttt{genind} object.
Positions of the SNPs are stored as names of the loci:
<<>>=
head(locNames(obj))
@





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Extracting polymorphism from proteic sequences}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Alignments of proteic sequences can be exploited in \textit{adegenet} in the same way as DNA sequences (see
section above).
Alignments are scanned for polymorphic sites, and only those are retained to form a \texttt{genind} object.
Loci correspond to the position of the residue in the alignment, and alleles correspond to the
different amino-acids (AA).
Aligned proteic sequences are stored as objects of class \texttt{alignment} in the \emph{seqinr}
package \cite{np160}.
See \texttt{?as.alignment} for a description of this class.
The function extracting polymorphic sites from \texttt{alignment} objects is \texttt{alignment2genind}.

Its use is fairly simple. It is here illustrated using a small dataset of aligned proteic sequences:
<<seqinr1>>=
library(seqinr)
mase.res   <- read.alignment(file=system.file("sequences/test.mase",
                             package="seqinr"), format = "mase")
mase.res
x <- alignment2genind(mase.res)
x
@
The six aligned protein sequences (\texttt{mase.res}) have been scanned for polymorphic sites, and
these have been extracted to form the \texttt{genind} object \texttt{x}.
Note that several settings such as the characters corresponding to missing values (i.e., gaps) and
the polymorphism threshold for a site to be retained can be specified through the function's
arguments (see \texttt{?alignment2genind}).

The names of the loci directly provides the indices of polymorphic sites:
<<>>=
head(locNames(x))
@
The table of polymorphic sites can be reconstructed easily by:
<<>>=
tabAA <- genind2df(x)
dim(tabAA)
tabAA[, 1:20]
@
The global AA composition of the polymorphic sites is given by:
<<>>=
table(unlist(tabAA))
@

Now that polymorphic sites have been converted into a \texttt{genind} object, simple distances can be
computed between the sequences.
Note that \textit{adegenet} does not implement specific distances for protein sequences, we only use the
simple Euclidean distance.
Fancier protein distances are implemented in R; see for instance \texttt{dist.alignment} in the
\emph{seqinr} package, and \texttt{dist.ml} in the \emph{phangorn} package.

<<>>=
D <- dist(tab(x))
D
@
This matrix of distances is small enough for one to interprete the raw numbers.
However, it is also very straightforward to represent these distances as a tree or in a reduced space.
We first build a Neighbor-Joining tree using the \emph{ape} package:
<<njAA>>=
library(ape)
tre <- nj(D)
par(xpd=TRUE)
plot(tre, type="unrooted", edge.w=2)
edgelabels(tex=round(tre$edge.length,1), bg=rgb(.8,.8,1,.8))
@

The best possible planar representation of these Euclidean distances is achieved by Principal
Coordinate Analyses (PCoA), which in this case will give identical results to PCA of the original
(centred, non-scaled) data:
<<>>=
pco1 <- dudi.pco(D, scannf=FALSE,nf=2)
s.label(pco1$li*1.1, clab=0, pch="")
textplot(pco1$li[,1], pco1$li[,2], words=rownames(pco1$li),
         cex=1.4, new=FALSE, xpd=TRUE)
title("Principal Coordinate Analysis\n-based on proteic distances-")
@




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Using \texttt{genind}/\texttt{genpop} constructors}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\texttt{genind} or \texttt{genpop} objects are best obtained using the procedures described above.
However, one can also build new \texttt{genind} or \texttt{genpop} objects using the constructor \texttt{new()}.
In this case, the function must be given as main input an object corresponding to the \texttt{@tab}
slot: a matrix of integers with individuals in row and alleles in columns, with columns being named as '[marker].[allele]'.
Here is an example for \texttt{genpop} using a dataset from \textit{ade4}:
<<>>=
data(microsatt)
str(microsatt, max.level = 1) # a plain list with a data frame and three vectors
microsatt$tab[10:15,12:15]
@
\texttt{microsatt\$tab} contains alleles counts per populations, and can therefore be used to make a \texttt{genpop} object.
Moreover, column names are set as required, and row names are unique.
It is therefore safe to convert these data into a \texttt{genpop} using the constructor:
<<>>=
toto <- new("genpop", tab=microsatt$tab)
toto
summary(toto)
@




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Exporting data}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
The \texttt{genind} class tends to become a standard in population genetics packages.
As of \emph{adegenet} 2.0.0, export functions towards \emph{hierfstat} have been removed, as the
package now uses \texttt{genind} objects as a native class.
Similarly, export towards the package \emph{genetics} have been removed, as \emph{adegenet} now
relies on \emph{pegas} for basic population genetics.
\\


A generic way to export data is to produce a \texttt{data.frame} of genotypes
coded by character strings.
This is done by \texttt{genind2df}:
<<genind2df>>=
obj <- genind2df(nancycats)
obj[1:5,1:5]
@

This function is flexible; for instance, one can separate alleles by any character string:
<<>>=
genind2df(nancycats,sep="|")[1:5,1:5]
@

Note that tabulations can be obtained as follows using '{$\backslash$}t' character.






\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Basics of data analysis}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Manipulating the data}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Data manipulation is meant to be particularly flexible in \textit{adegenet}.
First, as \texttt{genind} and \texttt{genpop} objects are basically formed
by a data matrix (the \texttt{@tab} slot), it is natural to subset these objects like it is done
with a matrix.
The \texttt{$[$} operator does this, forming a new object with the retained genotypes/populations and alleles:
<<>>=
data(microbov)
toto <- genind2genpop(microbov)
toto
popNames(toto)
titi <- toto[1:3, ]
popNames(titi)
@

\noindent The object \texttt{toto} has been subsetted, keeping only the
first three populations.
Of course, any subsetting available for a matrix can be used with \texttt{genind} and \texttt{genpop} objects.
In addition, we can subset loci directly using indices or logicals, in which case they refer to the
output of \texttt{locNames}:
<<>>=
nAll(titi)
tata <- titi[, loc=c(1, 3)]
tata
nAll(tata)
@

Alternatively, one can subset loci using their explicit name:
<<>>=
locNames(titi)
hel5 <- titi[, loc="HEL5"]
hel5
locNames(hel5)
@

When subsetting individuals/samples, some alleles may not be included in the subset anymore. In case you want these alleles to be dropped, use the \texttt{drop = TRUE} argument.

<<>>=
data(nancycats)

nAll(nancycats[1:3, ])
nAll(nancycats[1:3, , drop = TRUE])
@

To simplify the task of separating data by marker systematically, the function
\texttt{seploc} can be used.
It returns a list of objects (optionnaly, of data matrices), each
corresponding to a marker:
<<seploc>>=
sepCats <- seploc(nancycats)
class(sepCats)
names(sepCats)
sepCats$fca45
identical(tab(sepCats$fca45), tab(nancycats[,loc="fca45"]))
@

\noindent The object \texttt{sepCats\$fca45} only contains data of the
marker fca45.
\\

Following the same idea, \texttt{seppop} allows one to separate genotypes
in a \texttt{genind} object by population.
For instance, we can separate genotype of cattles in the dataset \texttt{microbov}
by breed:
<<seppop>>=
data(microbov)
obj <- seppop(microbov)
class(obj)
names(obj)
obj$Borgou
@

\noindent The returned object \texttt{obj} is a list of \texttt{genind}
objects each containing genotypes of a given breed.
\\


A last, rather vicious trick is to separate data by population and by marker.
This is easy using \texttt{lapply}; one can first separate population
then markers, or the contrary.
Here, we separate markers inside each breed in \texttt{obj}:
<<sepultim>>=
obj <- lapply(obj,seploc)
names(obj)
class(obj$Borgou)
names(obj$Borgou)
obj$Borgou$INRA63
@

For instance, \texttt{obj\$Borgou\$INRA63} contains genotypes of the
breed Borgou for the marker INRA63.
\\

Lastly, one may want to pool genotypes in different datasets, but having
the same markers, into a single dataset.
This is more than just merging the \texttt{@tab} components of all
datasets, because alleles can differ (they almost always do) and
markers are not necessarily sorted the same way.
The function \texttt{repool} is designed to avoid these problems.
It can merge any \texttt{genind} provided as arguments as soon as the
same markers are used.
For instance, it can be used after a \texttt{seppop} to retain only some populations:
<<repool>>=
obj <- seppop(microbov)
names(obj)
newObj <- repool(obj$Borgou, obj$Charolais)
newObj
popNames(newObj)
@
Done !
\\


Note that the content of \texttt{@other} can be processed during the conversion from \texttt{genind} to
\texttt{genpop} if the argument \texttt{process.other} is set to \texttt{TRUE}.
Only vectors of a length, or matrices with a number of rows matching the number individuals will be
processed. The way they are processed is defined by a function passed as the argument
\texttt{other.action} (defaulting to 'mean').
Let us illustrate this using \texttt{sim2pop}:
<<>>=
data(sim2pop)
sim2pop
nInd(sim2pop)
head(other(sim2pop)$xy)
dim(other(sim2pop)$xy)
@
The component \texttt{sim2pop@other\$xy} contains spatial coordinates of individuals from 2 populations.
<<>>=
other(genind2genpop(sim2pop, process.other=TRUE))
@
In this case, numeric vectors with a length corresponding to the number of individuals will we
averaged per groups; note that any other function than \texttt{mean} can be used by providing any
function to the argument \texttt{other.action}.
Matrices with a number of rows corresponding to the number of individuals are processed similarly.
\\


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Using summaries}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Both \texttt{genind} and \texttt{genpop} objects have a summary providing basic information about data.
Informations are both printed and invisibly returned as a list.

<<sumry,dev='pdf'>>=
toto <- summary(nancycats)
names(toto)

par(mfrow=c(2,2))

plot(toto$n.by.pop, toto$pop.n.all, xlab="Colonies sample size",
     ylab="Number of alleles",main="Alleles numbers and sample sizes",
     type="n")
text(toto$n.by.pop,toto$pop.n.all,lab=names(toto$n.by.pop))

barplot(toto$loc.n.all, ylab="Number of alleles",
        main="Number of alleles per locus")

barplot(toto$Hexp-toto$Hobs, main="Heterozygosity: expected-observed",
        ylab="Hexp - Hobs")

barplot(toto$n.by.pop, main="Sample sizes per population",
        ylab="Number of genotypes",las=3)
par(mfrow = c(1,1))
@

Is mean observed H significantly lower than mean expected H ?

<<>>=
bartlett.test(list(toto$Hexp,toto$Hobs))
t.test(toto$Hexp,toto$Hobs,pair=T,var.equal=TRUE,alter="greater")
@
Yes, it is.





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Testing for Hardy-Weinberg equilibrium}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
As of version 2.0.0, \textit{adegenet} is designed to work alongside a number of other packages,
especially \textit{pegas} and \textit{hierfstat} for a number of classical population genetics methods.
The former function \texttt{HWE.test.genind} has consequently been removed, and replaced by
\emph{pegas}'s \texttt{hw.test}, which performs one test per locus:
<<HWE>>=
library(pegas)
data(nancycats)
cats.hwt <- hw.test(nancycats, B=0)
cats.hwt
@

Note that \texttt{B=0} is used for the parametric version; larger numbers will indicate the number
of permutations to use for a Monte-Carlo version.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Measuring and testing population structure (a.k.a $F$ statistics)}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Population structure is traditionally measured and tested using $F$ statistics, in particular $F_{st}$.
As of version 2.0.0, \textit{adegenet} relies on \emph{hierfstat} and \emph{pegas} for most $F$ statistics.

Can we find any population structure in the cat colonies from Nancy?
The basic Weir and Cockerham \cite{tj342} $F$ statistics are provided by the
\texttt{wc()} function from \emph{heirfstat}:

<<>>=
library("hierfstat")
wc(nancycats)
@
This table provides two F statistics $Fst$ (pop/total), and $Fis$ (ind/pop).
These are overall measures which take into account all genotypes and all loci.
\\

For more detail, \emph{pegas} provides estimates by locus:
<<>>=
library(pegas)
ftab <- Fst(as.loci(nancycats))
ftab # per-locus F-statistics
colMeans(ftab) # global F-statistics
@

Confidence intervals for these $F$ statistics can be obtained through the 
\texttt{boot.vc()} function in \emph{hierfstat}, which takes a data frame of 
population strata and a data frame of genotypes. You can convert the genind 
object to this data frame with \emph{genind2hierfstat()}

% NOTE: This used to give people a test for significance using gstat.randtest,
% which no longer exists in hierfstat (I don't know when it was removed). This
% is not as pretty, but it serves a similar purpose (but is unsatisfying for 
% people who want to know if something is _significant_). 

<<>>=
nc <- genind2hierfstat(nancycats)
boot.vc(nc[1], nc[-1])$ci
@

Finally, pairwise $F_{st}$ is frequently used as a measure of distance between populations.
The function \texttt{pairwise.fst} computes Nei's estimator \cite{tj814} of pairwise $Fst$, defined as:
$$
Fst(A,B) = \frac{H_t - (n_AH_s(A) + n_BH_s(B))/(n_A + n_B)}{Ht}
$$
where A and B refer to the two populations of sample size $n_A$ and $n_B$ and respective
expected heterozygosity $H_s(A)$ and $H_s(B)$, and $H_t$ is the expected heterozygosity in the whole dataset.
For a given locus, expected heterozygosity is computed as $1 - \sum p_i^2$, where $p_i$ is the
frequency of the $i$th allele, and the $\sum$ represents summation over all alleles.
For multilocus data, the heterozygosity is simply averaged over all loci.
These computations are achieved for all pairs of populations by the function \texttt{genet.dist()} with the ``Nei87" method; we
illustrate this on a subset of individuals of \texttt{nancycats} (computations for the whole dataset
would take a few tens of seconds):
<<>>=
matFst <- genet.dist(nancycats[1:50, ], method = "Nei87")
matFst
@

The resulting matrix is Euclidean when there are no missing values:
<<>>=
is.euclid(matFst)
@

It can therefore be used in a Principal Coordinate Analysis (which requires Euclideanity), used to
build trees, etc.







%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Estimating inbreeding}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Inbreeding refers to an excess of homozygosity in a given individual due to the mating of
genetically related parents.
This excess of homozygosity is due to the fact that there are non-negligible chances of inheriting
two identical alleles from a recent common ancestor.
Inbreeding can be associated to a loss of fitness leading to "\textit{inbreeding depression}".
Typically, loss of fitness is caused by recessive deleterious alleles which have usually low
frequency in the population, but for which inbred individuals are more likely to be homozygotes.
\\


The inbreeding coefficient $F$ is defined as the probability that at a given locus, two identical
alleles have been inherited from a common ancestor.
In the absence of inbreeding, the probability of being homozygote at one loci is (for diploid
individuals) simply $\sum_i p_i^2$ where $i$ indexes the alleles and $p_i$ is the frequency of
allele $i$.
This can be generalized incorporating $F$ as:
$$
p(\mbox{homozygote}) = F + (1-F) \sum_ip_i^2
$$
and even more generally, for any ploidy $\pi$:
$$
p(\mbox{homozygote}) = F + (1-F) \sum_ip_i^{\pi}
$$
This therefore allows for computing the likelihood of a given state (homozygote/heterozygote) in a
given genotype (log-likelihood are summed across loci for more than one marker).
\\

This estimation is achieved by \texttt{inbreeding}.
Depending on the value of the argument \texttt{res.type}, the function returns a sample from the
likelihood function (\texttt{res.type='sample'}) or the likelihood function itself, as a R function (\texttt{res.type='function'}).
While likelihood functions are quickly obtained and easy to display graphically, sampling from the
distributions is more computer intensive but useful to derive summary statistics of the distributions.
Here, we illustrate \texttt{inbreeding} using the \texttt{microbov} dataset, which contains cattle
breeds genotypes for 30 microsatellites; to focus on breed Salers only, we use \texttt{seppop}:
<<>>=
data(microbov)
sal <- seppop(microbov)$Salers
sal
@
We first compute the mean inbreeding for each individual, and plot the resulting distribution:
<<>>=
temp <- inbreeding(sal, N=100)
class(temp)
head(names(temp))
head(temp[[1]],20)
@
\texttt{temp} is a list of values sampled from the likelihood distribution of each individual; means
values are obtained for all individuals using \texttt{sapply}:
<<>>=
Fbar <- sapply(temp, mean)
@
<<>>=
hist(Fbar, col="firebrick", main="Average inbreeding in Salers cattles")
@

\noindent We can see that some individuals (actually, a single one) have higher inbreeding ($>$0.4). We can recompute
inbreeding for this individual, asking for the likelihood function to be returned:
<<>>=
which(Fbar>0.4)
F <- inbreeding(sal, res.type="function")[which(Fbar>0.4)]
F
@
The output object \texttt{F} can seem a bit cryptic: it is an function embedded within a hidden environment.
This does not matter, however, since it is easily represented:
<<>>=
plot(F$FRBTSAL9266, main=paste("Inbreeding of individual",names(F)),
     xlab="Inbreeding (F)", ylab="Probability density")
@

\noindent Indeed, this individual shows subsequent inbreeding, with about 50\% chances of being
homozygote through inheritance from a common ancestor of its parents.






\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Multivariate analysis}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{General overview}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Multivariate analysis consists in summarising a strongly multivariate information into a few
synthetic variables.
In genetics, such approaches are useful to get a simplified picture of the genetic diversity
obersved amongst individuals or populations.
A review of multivariate analysis in population genetics can be found in \cite{tjart10}.
Here, we aim at providing an overview of some applications using methods implemented in \textit{ade4}
and \textit{adegenet}.
\\


Useful functions include:
\begin{itemize}
  \item \texttt{tab} (\textit{adegenet}): extract allele counts or frequencies and replaces missing
    data; useful, among other things, before running a principal component analysis (PCA).
  \item \texttt{dudi.pca} (\textit{ade4}): implements PCA; can be used on transformed allele
    frequencies of individuals or populations.
  \item \texttt{dudi.ca} (\textit{ade4}): implements Correspondance Analysis (CA); can be used on raw
    allele counts of populations (\texttt{@tab} slot in \texttt{genpop} objects).
  \item \texttt{dist.genpop} (\textit{adegenet}): implements 5 pairwise genetic distances between populations
  \item \texttt{pairwise.fst} (\textit{adegenet}): implements pairwise $F_{ST}$, which is also a
    Euclidean distance between populations.
  \item \texttt{dist} (\textit{stats}): computes pairwise distances between multivariate
    observations; can be used on raw or transformed allele frequencies.
  \item \texttt{dudi.pco} (\textit{ade4}): implements Principal Coordinates Analysis (PCoA); this
    methods finds synthetic variables which summarize a Euclidean distance matrix as best as
    possible; can be used on outputs of \texttt{dist}, \texttt{dist.genpop}, and \texttt{pairwise.fst}.
  \item \texttt{is.euclid} (\textit{ade4}): tests whether a distance matrix is Euclidean, which is a
    pre-requisite of PCoA.
  \item \texttt{cailliez} (\textit{ade4}): renders a non-Euclidean distance matrix Euclidean by
    adding a constant to all entries.
  \item \texttt{dapc} (\textit{adegenet}): implements the Discriminant Analysis of Principal
    Components (DAPC \cite{tjart19}), a powerful method for the analysis of population genetic structures; see
    dedicated tutorial (\textit{dapc}).
  \item \texttt{sPCA} (\textit{adegenet}): implements the spatial Principal Component Analysis
    (sPCA \cite{tjart04}), a method for the analysis of spatial genetic structures; see dedicated tutorial (\textit{dapc}).
  \item \texttt{glPca} (\textit{adegenet}): implements PCA for genome-wide SNP data stored as
    \texttt{genlight} objects; see dedicated tutorial (\textit{genomics}).
    %% \item \texttt{} (\textit{}):
\end{itemize}

Besides the procedures themselves, graphic functions are also often of the utmost importance; these include:
\begin{itemize}
  \item \texttt{scatter} (\textit{ade4,adegenet}): generic function to display multivariate
    analyses; in practice, the most useful application for genetic data is the one implemented in
    \texttt{adegenet} for DAPC results.
  \item \texttt{s.label} (\textit{ade4}): function used for basic display of principal components.
  \item \texttt{loadingplot} (\textit{adegenet}): function used to display the loadings (i.e.,
    contribution to a given structure) of alleles for a given principal component; annotates and returns the most
    contributing alleles.
  \item \texttt{s.class} (\textit{ade4}): displays two quantitative variables with known groups of
    observations, using inertia ellipses for the groups; useful to represent principal components
    when groups are known.
  \item \texttt{s.chull} (\textit{ade4}): same as \texttt{s.class}, except convex polygons are used
    rather than ellipses.
  \item \texttt{s.value} (\textit{ade4}): graphical display of a quantitative variable distributed
    over a two-dimensional space; useful to map principal components or allele frequencies over a
    geographic area.
  \item \texttt{colorplot} (\textit{adegenet}): graphical display of 1 to 3 quantitative variables distributed
    over a two-dimensional space; useful for combined representations of principal components over a geographic area.
    Can also be used to produce color versions of traditional scatterplots.
  \item \texttt{transp} (\textit{adegenet}): auxiliary function making colors transparent.
  \item \texttt{num2col} (\textit{adegenet}): auxiliary function transforming a quantitative
    variable into colors using a given palette.
  \item \texttt{assignplot} (\textit{adegenet}): specific plot of group membership probabilities for
    DAPC; see dedicated tutorial (\textit{dapc}).
  \item \texttt{compoplot} (\textit{adegenet}): specific 'STRUCTURE-like' plot of group membership probabilities for
    DAPC; see dedicated tutorial (\textit{dapc}).
  \item \texttt{add.scatter} (\textit{ade4}): add inset plots to an existing figure.
  \item \texttt{add.scatter.eig} (\textit{ade4}): specific application of \texttt{add.scatter} to
    add barplots of eigenvalues to an existing figure.
  %% \item \texttt{} (\textit{}): .
  %% \item \texttt{} (\textit{}): .
  %% \item \texttt{} (\textit{}): .
  %% \item \texttt{} (\textit{}): .
  %% \item \texttt{} (\textit{}): .
\end{itemize}

\noindent In the sections below, we briefly illustrate how these tools can be combined to extract information from
genetic data.




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Performing a Principal Component Analysis on \texttt{genind} objects}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The tables contained in \texttt{genind} objects can be submitted to a Principal
Component Analysis (PCA) to seek a summary of the genetic diversity among the
sampled individuals.  Such analysis is straightforward using \textit{adegenet}
to prepare data and \textit{ade4} for the analysis \textit{per se}.  One has
first to extract allele counts or frequencies from the \texttt{genind} object
and replace missing data (NAs) by the mean allele frequency. This is achieved by \texttt{tab}:

<<pcaexpl>>=
data(microbov)
sum(is.na(microbov$tab))
@
There are \Sexpr{sum(is.na(microbov$tab))} missing data, which will be replaced by \texttt{tab}:
<<>>=
X <- tab(microbov, freq = TRUE, NA.method = "mean")
class(X)
dim(X)
X[1:5,1:5]
@


The analysis can now be performed.
We disable the scaling in \texttt{dudi.pca}, as all 'variables' (alleles) are vary on a common scale. 
Note: in practice, retained axes can be chosen interactively by removing the arguments \texttt{scannf=FALSE,nf=3}.
<<>>=
pca1 <- dudi.pca(X, scale = FALSE, scannf = FALSE, nf = 3)
barplot(pca1$eig[1:50], main = "PCA eigenvalues", col = heat.colors(50))
@
<<>>=
pca1
@

The output object \texttt{pca1} is a list containing various information; of particular interest are:
\begin{itemize}
\item \texttt{\$eig}: the eigenvalues of the analysis, indicating the amount of variance represented
  by each principal component (PC).
\item \texttt{\$li}: the principal components of the analysis; these are the synthetic variables
  summarizing the genetic diversity, usually visualized using scatterplots.
\item \texttt{\$c1}: the allele loadings, used to compute linear combinations forming the PCs;
  squared, they represent the contribution to each PCs.
\end{itemize}

The basic scatterplot for this analysis can be obtained by:
<<>>=
s.label(pca1$li)
title("PCA of microbov dataset\naxes 1-2")
add.scatter.eig(pca1$eig[1:20], 3,1,2)
@

\noindent However, this figure can largely be improved.
First, we can use \texttt{s.class} to represent both the genotypes and inertia ellipses for populations.
<<>>=
s.class(pca1$li, pop(microbov))
title("PCA of microbov dataset\naxes 1-2")
add.scatter.eig(pca1$eig[1:20], 3,1,2)
@

\noindent This plane shows that the main structuring is between African an French breeds, the second structure reflecting genetic diversity among African breeds.
The third axis reflects the diversity among French breeds:
<<>>=
s.class(pca1$li,pop(microbov),xax=1,yax=3,sub="PCA 1-3",csub=2)
title("PCA of microbov dataset\naxes 1-3")
add.scatter.eig(pca1$eig[1:20],nf=3,xax=1,yax=3)
@

\noindent Overall, all breeds seem well differentiated.
~\\

However, we can yet improve these scatterplots, which are fortunately easy to customize.
For instance, we can remove the grid, choose different colors for the groups, use larger dots and transparency to
better assess the density of points, and remove internal segments of the ellipses:
<<>>=
col <- funky(15)
s.class(pca1$li, pop(microbov),xax=1,yax=3, col=transp(col,.6), axesell=FALSE,
        cstar=0, cpoint=3, grid=FALSE)
@
~\\


Let us now assume that we ignore the group memberships.
We can still use color in an informative way.
For instance, we can recode the principal components represented in the scatterplot on the RGB
scale:
<<>>=
colorplot(pca1$li, pca1$li, transp=TRUE, cex=3, xlab="PC 1", ylab="PC 2")
title("PCA of microbov dataset\naxes 1-2")
abline(v=0,h=0,col="grey", lty=2)
@

\noindent Colors are based on the first three PCs of the PCA, recoded respectively on the red, green, and blue channel.
In this figure, the genetic diversity is represented in two complementary ways: by the distances
(further away = more genetically different), and by the colors (more different colors = more
genetically different).
\\

We can represent the diversity on the third axis similarly:
<<>>=
colorplot(pca1$li[c(1,3)], pca1$li, transp=TRUE, cex=3, xlab="PC 1", ylab="PC 3")
title("PCA of microbov dataset\naxes 1-3")
abline(v=0,h=0,col="grey", lty=2)
@





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Performing a Correspondance Analysis on \texttt{genpop} objects}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Being contingency tables, the \texttt{@tab} slot in \texttt{genpop} objects can be submitted to a Correspondance Analysis (CA) to seek a typology of populations.
The approach is very similar to the previous one for PCA.
<<caexpl>>=
data(microbov)
obj <- genind2genpop(microbov)
ca1 <- dudi.coa(tab(obj),scannf=FALSE,nf=3)
barplot(ca1$eig,main="Correspondance Analysis eigenvalues",
        col=heat.colors(length(ca1$eig)))
@

Now we display the resulting typology using a basic scatterplot:
<<>>=
s.label(ca1$li, sub="CA 1-2",csub=2)
add.scatter.eig(ca1$eig,nf=3,xax=1,yax=2,posi="bottomright")
@

The same graph is derived for the axes 2-3:
<<>>=
s.label(ca1$li,xax=2,yax=3,lab=popNames(obj),sub="CA 1-3",csub=2)
add.scatter.eig(ca1$eig,nf=3,xax=2,yax=3,posi="topleft")
@
\noindent As in the PCA above, axes are to be interpreted separately in terms of continental differentiation, and between-breeds diversity.
Importantly, as in any analysis carried out at a population level, all information about the
diversity within populations is lost in this analysis.
See the tutorial on DAPC for an individual-based approach which is nontheless optimal in terms of
group separation (\textit{dapc}).
\\


Note that as an alternative, \emph{wordcloud} can be used to avoid overlaps in labels:
<<>>=
library(wordcloud)
set.seed(1)
s.label(ca1$li*1.2, sub="CA 1-2",csub=2, clab=0, cpoint="")
textplot(ca1$li[,1], ca1$li[,2], words=popNames(obj),
         cex=1.4, new=FALSE, xpd=TRUE)
add.scatter.eig(ca1$eig,nf=3,xax=1,yax=2,posi="bottomright")
@
However, only general trends can be interpreted: labels positions are randomised to avoid overlap,
so they no longer accurately position populations on the factorial axes.



\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Spatial analysis}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The R software probably offers the largest collection of spatial methods among statistical software.
Here, we briefly illustrate two methods commonly used in population genetics.
Spatial multivariate analysis is covered in a dedicated tutorial; see \textit{spca} tutorial for
more information.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Isolation by distance}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% % % % % % % % % % % % % % % % % % % % %
\subsubsection{Testing isolation by distance}
% % % % % % % % % % % % % % % % % % % % %
Isolation by distance (IBD) is tested using Mantel test between a matrix of genetic distances and a matrix of geographic distances.
It can be tested using individuals as well as populations.
This example uses cat colonies from the city of Nancy.
We test the correlation between Edwards' distances and Euclidean geographic distances between colonies.
<<ibd>>=
data(nancycats)
toto <- genind2genpop(nancycats)
Dgen <- dist.genpop(toto,method=2)
Dgeo <- dist(nancycats$other$xy)
ibd <- mantel.randtest(Dgen,Dgeo)
ibd
@
<<>>=
plot(ibd)
@

\noindent The original value of the correlation between the distance matrices is represented by the
dot, while histograms represent permuted values (i.e., under the absence of spatial structure).
Significant spatial structure would therefore result in the original value being out of the
reference distribution.
Here, isolation by distance is clearly not significant.
\\


Let us provide another example using a dataset of individuals simulated under an IBD model:
<<>>=
data(spcaIllus)
x <- spcaIllus$dat2B
Dgen <- dist(x$tab)
Dgeo <- dist(other(x)$xy)
ibd <- mantel.randtest(Dgen,Dgeo)
ibd
@
<<>>=
plot(ibd)
@

\noindent This time there is a clear isolation by distance pattern.


% % % % % % % % % % % % % % % % % % % % %
\subsubsection{Cline or distant patches?}
% % % % % % % % % % % % % % % % % % % % %
The correlation between genetic and geographic distances can occur under a range of different
biological scenarios.
Classical IBD would result in continuous clines of genetic differentiation and cause such correlation.
However, distant and differentiated populations would also result in such a pattern.
These are slightly different processes and we would like to be able to disentangle them.
A very simple first approach is simply plotting both distances:

<<>>=
plot(Dgeo, Dgen)
dist_lm <- lm(as.vector(Dgen) ~ as.vector(Dgeo))
abline(dist_lm, col="red", lty=2)
@

\noindent Most of the time, simple scatterplots fail to provide a good picture of the data as the
density of points in the scatterplot is badly displayed.
Colors can be used to provide better (and prettier) plots.
Local density is measured using a 2-dimensional kernel density estimation (\texttt{kde2d}), and the
results are displayed using \texttt{image}; \texttt{colorRampPalette} is used to generate a
customized color palette:

<<eval=TRUE>>=
library(MASS)
dens <- kde2d(as.vector(Dgeo), as.vector(Dgen), n=300)
myPal <- colorRampPalette(c("white", "blue", "gold", "orange", "red"))
plot(Dgeo, Dgen, pch=20,cex=.5)
image(dens, col=transp(myPal(300),.7), add=TRUE)
abline(dist_lm)
title("Isolation by distance plot")
@

The scatterplot clearly shows one single consistent cloud of point, without discontinuities which
would have indicated patches.
This is reassuring, since the data were actually simulated under an IBD (continuous) model.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Using Monmonier's algorithm to define genetic boundaries}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Monmonier's algorithm \cite{tj433} was originally designed to find boundaries of maximum differences between contiguous polygons of a tesselation.
As such, the method was basically used in geographical analysis.
More recently, \cite{np120} suggested that this algorithm could be employed to detect genetic boundaries among georeferecend genotypes (or populations).
This algorithm is implemented using a more general approach than the initial one in \textit{adegenet}.

Instead of using Voronoi tesselation as in the original version, the functions \texttt{monmonier} and \texttt{optimize.monmonier} can handle various neighbouring graphs such as Delaunay triangulation, Gabriel's graph, Relative Neighbours graph, etc.
These graphs define spatial connectivity among locations (of genotypes or populations), with couple of locations being neighbours (if connected) or not.
Another information is given by a set of markers which define genetic distances among these 'points'.
The aim of Monmonier's algorithm is to find the path through the strongest genetic distances between neighbours.
A more complete description of the principle of this algorithm will be found in the documentation of \texttt{monmonier}.
Indeed, the very purpose of this tutorial is simply to show how it can be used on genetic data.
\\

Let's take the example from the function's manpage and detail it.
The dataset used is \texttt{sim2pop}.

<<mon1>>=
data(sim2pop)
sim2pop
summary(sim2pop$pop)

temp <- sim2pop$pop
levels(temp) <- c(3,5)
temp <- as.numeric(as.character(temp))
plot(sim2pop$other$xy,pch=temp,cex=1.5,xlab='x',ylab='y')
legend("topright",leg=c("Pop A", "Pop B"),pch=c(3,5))
@

There are two sampled populations in this dataset, with inequal sample sizes (100 and 30).
Twenty microsatellite-like loci are available for all genotypes (no missing data).
\texttt{monmonier} requires several arguments to be specified:
<<mon2>>=
args(monmonier)
@

\noindent The first argument (\texttt{xy}) is a matrix of geographic coordinates, already stored in \texttt{sim2pop}.
Next argument is an object of class \texttt{dist}, which is the matrix of pairwise genetic distances.
For now, we will use the classical Euclidean distance between allelic profiles of the individuals.
This is obtained by:
<<mon3>>=
D <- dist(sim2pop$tab)
@

\noindent The next argument (\texttt{cn}) is a connection network.
Routines for building such networks are scattered over several packages, but all made available
through the function \texttt{chooseCN}.
Here, we disable the interactivity of the function (\texttt{ask=FALSE}) and select the second type of graph which is the graph of Gabriel (\texttt{type=2}).
<<mon4>>=
gab <- chooseCN(sim2pop$other$xy, ask=FALSE, type=2)
@

\noindent The obtained network is automatically plotted by the function.
It seems we are now ready to proceed to the algorithm.
<<mon5, eval=FALSE>>=
mon1 <- monmonier(sim2pop$other$xy, D, gab)
@
\begin{center}
\includegraphics[width=.5\textwidth]{figs/monthres1.png}
\end{center}

\noindent This plot shows all local differences sorted in decreasing order.
The idea behind this is that a significant boundary would cause local differences to decrease abruptly after the boundary.
This should be used to choose the \emph{threshold} difference for the algorithm to stop extending
the boundary.
Here, there is no indication af an actual boundary.
\\

Why do the algorithm fail to find a boundary?
Either because there is no genetic differentiation to be found, or because the signal differentiating both populations is too weak to overcome the random noise in genetic distances.
What is the $F_{st}$ between the two samples?
<<>>=
library(hierfstat)
genet.dist(sim2pop, method = "Nei87")
@

\noindent This value would be considered as very weak differentiation ($F_{ST}=0.023$).
Is it significant?
We can easily ellaborate a permutation test of this $F_{ST}$ value; to save computational time, we
use only a small number of replicates to generate $F_{ST}$ values in absence of population structure:

<<>>=
replicate(10, {
  pop(sim2pop) <- sample(pop(sim2pop))
  genet.dist(sim2pop, method = "Nei87")
})
@

$F_{ST}$ values in absence of population structure would be one order of magnitude lower (more
replicate would give a very low p-value --- just replace \texttt{10} by \texttt{200} in the above command).
In fact, the two samples are indeed genetically differentiated.
\\

Can Monmonier's algorithm find a boundary between the two populations?
Yes, if we get rid of the random noise.
This can be achieved using a simple ordination method such as Principal Coordinates Analysis.

<<mon6>>=
pco1 <- dudi.pco(D, scannf=FALSE, nf=1)
barplot(pco1$eig, main="Eigenvalues")
@

\noindent We retain only the first eigenvalue.
The corresponding coordinates are used to redefine the genetic distances among genotypes.
The algorithm is then re-run.
<<mon7>>=
D <- dist(pco1$li)
@
<<mon8,eval=FALSE>>=
mon1 <- monmonier(sim2pop$other$xy, D, gab)
@
\begin{center}
\includegraphics[width=.5\textwidth]{figs/monthres2.png}
\end{center}

<<mon9, echo=2>>=
mon1 <- monmonier(sim2pop$other$xy, D, gab, scan=FALSE)
mon1
@

\noindent This may take some time... but never more than five minutes on an 'ordinary' personnal computer.
The object \texttt{mon1} contains the whole information about the boundaries found.
As several boundaries can be seeked at the same time (argument \texttt{nrun}), you have to specify about which run and which direction you want to get informations (values of differences or path coordinates).
For instance:
<<mon10>>=
names(mon1)
names(mon1$run1)
mon1$run1$dir1
@

\noindent It can also be useful to identify which points are crossed
by the barrier; this can be done using \texttt{coords.monmonier}:
<<>>=
coords.monmonier(mon1)
@

\noindent The returned dataframe contains, in this order, the $x$ and
$y$ coordinates of the points of the barrier, and the identifiers of
the two 'parent' points, that is, the points whose barycenter is the
point of the barrier.

Finally, you can plot very simply the obtained boundary using the method \texttt{plot}:
<<>>=
plot(mon1)
@

\noindent see arguments in \texttt{?plot.monmonier} to customize this representation.
Last, we can compare the infered boundary with the actual distribution of populations:
<<>>=
plot(mon1, add.arrows=FALSE, bwd=10, col="black")
points(sim2pop$other$xy, cex=2, pch=20,
       col=fac2col(pop(sim2pop), col.pal=spectral))
legend("topright", leg=c("Pop A", "Pop B"), pch=c(20),
       col=spectral(2), pt.cex=2)
@

\noindent Not too bad...




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Simulating hybridization}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
The function \texttt{hybridize} allows to simulate hybridization between
individuals from two distinct genetic pools, or more broadly between
two \texttt{genind} objects.
Here, we use the example from the manpage of the function, to go a
little further.
Please have a look at the documentation, especially at the different
possible outputs (outputs for the software STRUCTURE is notably available).
<<hybr>>=
temp <- seppop(microbov)
names(temp)
salers <- temp$Salers
zebu <- temp$Zebu
zebler <- hybridize(salers, zebu, n=40, pop="zebler")
@

\noindent A first generation (F1) of hybrids 'zebler' is obtained.
Is it possible to perform a backcross, say, with 'salers' population?
Yes, here it is:
<<>>=
F2 <- hybridize(salers, zebler, n=40)
F3 <- hybridize(salers, F2, n=40)
F4 <- hybridize(salers, F3, n=40)
@
Finally, note that despite this example shows hybridization between
diploid organisms, \texttt{hybridize} is not restrained to this case.
In fact, organisms with any even level of ploidy can be used, in which
case half of the genes is taken from each reference population.
Ultimately, more complex mating schemes could be
implemented... suggestion or (better) contributions are welcome!




\newpage
\bibliography{biblioTJ}
\bibliographystyle{plain}

\end{document}

